import { z } from "zod";
import { DecisionEventSchema, type DecisionEvent } from "./events";
import {
  DirectionSchema,
  StrategyDeploymentSchema,
  StrategyDecisionSchema,
  type StrategyDecision,
  type StrategyDefinition,
  type StrategyDeployment,
} from "./contracts";

/**
 * Shared backtest knobs understood by every strategy package.
 *
 * Strategies are free to interpret richer execution options through their own
 * deployment config, but these baseline controls must remain stable across the
 * platform so UI/API layers can reason about a backtest without knowing the
 * strategy internals.
 */
export const StrategyBacktestOptionsSchema = z.object({
  initialEquity: z.number().finite().positive(),
  feeRate: z.number().finite().min(0).default(0),
  slippageBps: z.number().finite().min(0).default(0),
});
export type StrategyBacktestOptions = z.infer<
  typeof StrategyBacktestOptionsSchema
>;

/**
 * Minimal normalized trade summary emitted by every strategy-specific trade
 * engine. Individual strategies can return richer trade artifacts as part of
 * the backtest result, but the shared comparison/reporting layer can always
 * rely on this stable shape.
 */
export const BacktestTradeSummarySchema = z.object({
  id: z.union([z.string().min(1), z.number().int()]),
  side: DirectionSchema.optional(),
  entryTime: z.number().int().nonnegative().optional(),
  closeTime: z.number().int().nonnegative().optional(),
  netPnl: z.number().finite(),
});
export type BacktestTradeSummary = z.infer<typeof BacktestTradeSummarySchema>;

/**
 * Shared performance metrics expected from every strategy backtest. Keeping
 * these metrics aligned makes strategy comparison possible even when each
 * strategy uses a very different internal trade engine.
 */
export const StrategyBacktestMetricsSchema = z.object({
  totalTrades: z.number().int().nonnegative(),
  wins: z.number().int().nonnegative(),
  losses: z.number().int().nonnegative(),
  winRate: z.number().finite().min(0).max(1),
  netPnl: z.number().finite(),
  grossProfit: z.number().finite(),
  grossLoss: z.number().finite().nonnegative(),
  maxDrawdownPct: z.number().finite().min(0),
  endingEquity: z.number().finite(),
});
export type StrategyBacktestMetrics = z.infer<
  typeof StrategyBacktestMetricsSchema
>;

/**
 * Decision record generated by the pure replay step and then consumed by a
 * strategy-specific trade engine. This keeps decision evidence and execution
 * simulation separated.
 */
export const BacktestDecisionRecordSchema = z.object({
  index: z.number().int().nonnegative(),
  event: DecisionEventSchema,
});
export type BacktestDecisionRecord = z.infer<
  typeof BacktestDecisionRecordSchema
>;

/**
 * Shared request contract for strategy package backtests.
 *
 * `contexts` are the prebuilt decision inputs for the deployment. This keeps
 * backtests strategy-centric and fully independent from bots and execution
 * accounts.
 */
export interface StrategyBacktestRequest<TContext> {
  requestId: string;
  deployment: StrategyDeployment;
  contexts: TContext[];
  options: StrategyBacktestOptions;
}

/**
 * Result emitted by a strategy-owned trade engine after it consumes replayed
 * decisions.
 */
export interface StrategyTradeEngineResult<
  TTrade extends BacktestTradeSummary = BacktestTradeSummary,
  TArtifacts = Record<string, unknown>,
> {
  trades: TTrade[];
  metrics: StrategyBacktestMetrics;
  artifacts?: TArtifacts;
}

/**
 * Strategy-owned execution simulator. This is the dedicated "backtester"
 * specific to a strategy family: it decides how strategy decisions become
 * positions, exits, continuous re-entries, DCA ladders, and any other
 * execution semantics.
 */
export interface StrategyTradeEngine<
  TContext,
  TDecision extends StrategyDecision,
  TTrade extends BacktestTradeSummary = BacktestTradeSummary,
  TArtifacts = Record<string, unknown>,
> {
  run(input: {
    request: StrategyBacktestRequest<TContext>;
    decisions: Array<BacktestDecisionRecord & { decision: TDecision }>;
  }): StrategyTradeEngineResult<TTrade, TArtifacts>;
}

/**
 * Shared final backtest result returned by every strategy package. The trade
 * engine remains strategy-specific, but the outer contract stays stable across
 * strategies.
 */
export interface StrategyBacktestResult<
  TDecision extends StrategyDecision = StrategyDecision,
  TTrade extends BacktestTradeSummary = BacktestTradeSummary,
  TArtifacts = Record<string, unknown>,
> extends StrategyTradeEngineResult<TTrade, TArtifacts> {
  requestId: string;
  deploymentId: string;
  strategyId: string;
  strategyVersion: string;
  decisions: Array<BacktestDecisionRecord & { decision: TDecision }>;
}

/**
 * Package-level contract for pure strategies.
 *
 * A strategy package owns:
 * - the pure strategy definition
 * - the strategy-specific trade engine used for backtesting/replay
 *
 * It does not own bots, exchange credentials, or infrastructure concerns.
 */
export interface StrategyPackage<
  TConfig extends Record<string, unknown>,
  TContext,
  TDecision extends StrategyDecision,
  TTrade extends BacktestTradeSummary = BacktestTradeSummary,
  TArtifacts = Record<string, unknown>,
> {
  definition: StrategyDefinition<TConfig, TContext, TDecision>;
  tradeEngine: StrategyTradeEngine<TContext, TDecision, TTrade, TArtifacts>;
}

/**
 * Lightweight parser for shared backtest requests when callers need runtime
 * validation of the non-generic envelope.
 */
export const StrategyBacktestEnvelopeSchema = z.object({
  requestId: z.string().min(1),
  deployment: StrategyDeploymentSchema,
  options: StrategyBacktestOptionsSchema,
});

/**
 * Helper used by tests and adapters to validate the stable, non-generic
 * portion of the final result envelope.
 */
export const StrategyBacktestResultEnvelopeSchema = z.object({
  requestId: z.string().min(1),
  deploymentId: z.string().min(1),
  strategyId: z.string().min(1),
  strategyVersion: z.string().min(1),
  metrics: StrategyBacktestMetricsSchema,
  decisions: z.array(BacktestDecisionRecordSchema.extend({ decision: StrategyDecisionSchema })),
});
